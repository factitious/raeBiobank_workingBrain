---
title: "workingBrain: UK Biobank metadata."
output: html_notebook
---

## Setup and load data

Load needed libraries 
```{r loadLibs, echo=FALSE}
library(readxl); library(tidyverse); library(dplyr); library(naniar); library(ggplot2); library(jsonlite);
library(data.tree); library(circlepackeR); library(igraph); library(networkD3); library(htmlwidgets)
```


Load the data and have a look at the first few rows.
```{r loadData}
metaData_all <- read_excel("~/GoogleDrive/Git/raeBiobank/RR/workingBrain_dataFields.xlsx", 
    sheet = "allData_BB")

head(metaData_all)
```

This is all the datafields in the UK Biobank data set, so we need to filter for this specific study (i.e. based on the variable 'inBasket')
```{r filterData}
metaData<- filter(metaData_all, inBasket == T)
head(metaData)
```

## Explore
```{r checks1}
# Do we have the right number of rows? 
nrow(metaData); 

# Do we have the right number of columns?
ncol(metaData); 

# How many 'complete cases' (no rows/cols missing)?
sum(complete.cases(metaData))
```

How many different 'Paths' are there? Will use to create 'Category' field, that is more intuitive and removes some of the information that we're not really interested in (e.g. that that data was aquired through 'Touchscreen'). 
```{r allPaths}
unique(metaData$Path)
```

The following are various steps to make the data more intuitive and easier to work with. The main aim is to divide the unhelpful (and in this state unusable) `Path` variable into columns that could actually help us make sense of the data. Ideallly would've done everything inside a 'pipe' (i.e.e %>%), but it waas being really stubborn an not allowing me to cut NA\s while keeping my rows -> Had to go with a bit of an inelegant solution, i.e. iteratively splitting the columns and making the desired changes and them putting them back together.

```{r splitPaths, echo = FALSE}

# Split "Path" column based on ">" separator
metaData_filtered <- metaData %>%
  rename(CategoryID = Category) %>% # Rename original "Category" column to what it actually is, i.e. "CategoryID"
  separate(Path, c("Medium", "CatVal1", "CatVal2","CatVal3", "CatVal4"), ">") %>% # split "Path" column.
  
  replace_with_na_if(.predicate = is.character,condition = ~.x == " Touchscreen ") %>% # remove "Touchscreen" column value from rows that contain them
  replace_with_na_if(.predicate = is.character,condition = ~.x == " Brain MRI ") %>% # remove "Brain MRI" column value from rows that contain them
  replace_with_na_if(.predicate = is.character,condition = ~.x == " MET Scores") %>% # remove "Brain MRI" column value from rows that contain them
  replace_with_na_if(.predicate = is.character,condition = ~.x == " Reception") %>% # remove "Brain MRI" column value from rows that contain them
  
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Cognitive function online ", " Cognitive function ")) %>% # Replace 'Cognitive function online' with 'Cognitive function'
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Baseline characteristics", " Sociodemographics_Baseline")) %>% # Replace 'Baseline characteristics' with 'Sociodemographics'
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Ongoing characteristics", " Sociodemographics_Ongoing")) %>% # Replace 'Ongoing characteristics' with 'Sociodemographics'
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Baseline characteristics ", " Sociodemographics")) %>% 
  # Replace 'Baseline characteristics' with 'Sociodemographics': Note that this is probably a bad way of doing this. It works for us out of luck (i.e. the spacing of 'Baseline characteristics' in the two separate cases) as we want to do two different things with them but if you want to do anywthing else with the data, this will likely lead to problems.
  mutate(CatVal2 = replace(CatVal2, is.na(CatVal2) & CatVal1 == " Work environment", " Employment history")) %>% # Get rid of extra NAs that result from 'Work environment'
  mutate(CatVal1 = replace(CatVal1, is.na(CatVal1) & CatVal2 == " Psychosocial factors " & CatVal3 == " Mental health", " Mental health_Other")) %>%
  mutate(CatVal1 = replace(CatVal1, is.na(CatVal1) & CatVal2 == " Psychosocial factors " & CatVal3 == " Social support", " Mental health_Social support")) %>%
  replace_with_na_if(.predicate = is.character,condition = ~.x == " Psychosocial factors ") %>%
  

  
  mutate(CatVal1 = replace(CatVal1,  CatVal1 == " Work environment " & CatVal2 == " Medical information", " Health and medical history ")) %>%

  mutate(CatVal1 = replace(CatVal1, is.na(CatVal1) & CatVal2 == " Sociodemographics " & CatVal3 == " Employment", " Employment_Employment: Current")) %>%
  mutate(CatVal2 = replace(CatVal2, CatVal1 ==" Employment_Current" & CatVal2 == " Sociodemographics " & CatVal3 == " Employment", " DELETEME")) %>%
  mutate(CatVal3 = replace(CatVal3, CatVal1 ==" Employment_Current" & CatVal2 == " DELETEME" & CatVal3 == " Employment", " DELETEME")) %>%
  
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Work environment " & CatVal2 == " Employment history", " Employment")) %>%
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Work environment" & CatVal2 == " Employment history", " Employment")) %>% # Duplicate due to whitespace
  
  mutate(CatVal2 = replace(CatVal2, CatVal1 == " Employment" & CatVal2 == " Employment history", " Employment: History")) %>%

  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Verbal interview " & CatVal2 == " Medical conditions", " Health and medical history ")) %>%
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Verbal interview " & CatVal2 == " Employment", " Employment")) %>%
  mutate(CatVal2 = replace(CatVal2, CatVal1 == " Employment" & CatVal2 == " Employment", " Other")) %>%
  
  mutate(CatVal1 = replace(CatVal1, CatVal1 == " Recruitment ", " Sociodemographics_Baseline")) %>%

  unite("MetaCat", CatVal1:CatVal4) # put together all the columns previously split into "MetaCat" column.

# Remove all the "NA"s from the names.
metaData_filtered$MetaCat <- sub("NA_", "", metaData_filtered$MetaCat)
metaData_filtered$MetaCat <- sub("_NA", "", metaData_filtered$MetaCat)
metaData_filtered$MetaCat <- sub("_NA*", "", metaData_filtered$MetaCat)  


metaData_filtered <- metaData_filtered %>%
  separate(MetaCat, c("MetaCat", "Category"), "_") # split into "MetaCat" and "Category"

# Removing whitespace from vars.
metaData_filtered$MetaCat <- sub("^\\s+", "", metaData_filtered$MetaCat)
metaData_filtered$MetaCat <- sub("\\s+$", "", metaData_filtered$MetaCat)

metaData_filtered$Category <- sub("^\\s+", "", metaData_filtered$Category)
metaData_filtered$Category <- sub("\\s+$", "", metaData_filtered$Category)

```


```{r splitPahts_show}
unique(metaData_filtered$MetaCat)
unique(metaData_filtered$Category)
```

## Visualize

```{r circlePack}
#trim_metaData <- metaData_filtered %>%
#  select(Medium, MetaCat, Category, Field, `Value Type`)

#trim_metaData$pathString <- file.path("world", trim_metaData$MetaCat, trim_metaData$Category)
#trim_metaData$value <- sample(seq(1:nrow(trim_metaData)), nrow(trim_metaData))

#trimmed_cp <- circlepackeR(as.Node(trim_metaData), size = "value", color_min = "hsl(54, 29%, 73%)", color_max = "hsl(137, 100%, 19%")

metaData_filtered$pathString <- file.path("world", metaData_filtered$MetaCat, metaData_filtered$Category)
metaData_filtered$value <- sample(seq(1:nrow(metaData_filtered)), nrow(metaData_filtered))

full_p <- circlepackeR(as.Node(metaData_filtered), size = "value", color_min = "hsl(24,91%,73%)", color_max = "hsl(249,91%,36%)")

show(full_p)

```



### Misc. helpful design stuff.

Example of interactive network (might need to go a different route, e.g. forceNetwork, if we want a DAG)
```{r simpleNetwork}
# create a dataset:
data <- tibble(
  from=c("A", "A", "B", "D", "C", "D", "E", "B", "C", "D", "K", "A", "M"),
  to=c("B", "E", "F", "A", "C", "A", "B", "Z", "A", "C", "A", "B", "K")
)

# Plot
p <- simpleNetwork(data, height="100px", width="100px",        
        Source = 1,                 # column number of source
        Target = 2,                 # column number of target
        linkDistance = 10,          # distance between node. Increase this value to have more space between nodes
        charge = -900,              # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
        fontSize = 14,              # size of the node names
        fontFamily = "serif",       # font og node names
        linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
        nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
        opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
        zoom = T                    # Can you zoom on the figure?
        )

p
```


```{r circlePack_example}
# create a nested data frame giving the info of a nested dataset:
data <- data.frame(
  root=rep("root", 15),
  group=c(rep("group A",5), rep("group B",5), rep("group C",5)), 
  subgroup= rep(letters[1:5], each=3),
  subsubgroup=rep(letters[1:3], 5),
  value=sample(seq(1:15), 15)
)

# Change the format. This use the data.tree library. This library needs a column that looks like root/group/subgroup/..., so I build it
library(data.tree)
data$pathString <- paste("world", data$group, data$subgroup, data$subsubgroup, sep = "/")
population <- as.Node(data)

# Make the plot
#circlepackeR(population, size = "value")

# You can custom the minimum and maximum value of the color range.
p <- circlepackeR(population, size = "value", color_min = "hsl(24,91%,73%)", color_max = "hsl(249,91%,36%)")

show(p)

# save the widget
# library(htmlwidgets)
# saveWidget(p, file=paste0( getwd(), "/HtmlWidget/circular_packing_circlepackeR2.html"))
```













